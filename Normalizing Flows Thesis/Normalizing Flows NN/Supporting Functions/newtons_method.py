# -*- coding: utf-8 -*-
"""
Created on Thu Mar 16 14:02:39 2023

@author: Sclin
"""

import numpy as np
import math
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from pdf_to_samples import pdf_to_samples
from otsu_on_gaussian import custom_otsu
from scipy.interpolate import PchipInterpolator
import scipy.integrate as integrate
from scipy.integrate import quad
from scipy.optimize import newton



N = 200
L = -3.5
R = 3.5
x = np.linspace(L,R,N)
k = np.delete(x,0)
k = np.delete(k,-1)
s = 1.0
a = 4

def fx_fun(x,a,s):
    fun_mat = np.zeros(len(x))
    for ii in range(len(x)):
        fun_mat[ii] = 1/(s*math.sqrt(2*math.pi))*np.exp(-x[ii]**2/(2*s**2))*(1+math.erf(a*x[ii]/(s*np.sqrt(2))))
    return fun_mat

# plotting the Skew Distribution's PDF
fx_f = fx_fun(x,a,s)
plt.plot(x,fx_f)
plt.grid()
plt.title('PDF of Skew Distribution')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.show()


# Note pdf to samples will plot the x,fx_f curve, the function curve, 
#   the gaussian that samples it
ps = pdf_to_samples(x, fx_f, 1, 500000)

# Calculating Otsu on the distribution generated by the pdf to samples function
kstar = custom_otsu(ps,2)

# Now we take the histogram, ps, and turn that into a curve
KDE = sns.kdeplot(data=ps)

# With the KDE Curve built we can now turn it into a function then 
#    do Newton on this bad larry
x_kde, y_kde = KDE.lines[0].get_data()
kde_func_curve = PchipInterpolator(x_kde,y_kde)
kde_func_curve_x = PchipInterpolator(x_kde,(y_kde*x_kde))

plt.subplot(1,2,1)
plt.plot(x_kde,y_kde)
plt.title('x and y kde values plotted')
plt.xlim([x_kde[0],x_kde[-1]])
plt.ylim([0,.7])
plt.show()

plt.subplot(1,2,2)
plt.plot(x_kde,kde_func_curve(x_kde))
plt.title('KDE Plot as a Function')
plt.xlim([x_kde[0],x_kde[-1]])
plt.ylim([0,.7])
plt.show()

plt.plot(x_kde,kde_func_curve_x(x_kde))
plt.title('KDE_x Plot as a Function')
plt.grid()
plt.show()

# Building out the G(k) function
G_k = []
oh = 1/2
for kk in x_kde[1:-1]:
    A = quad(kde_func_curve_x,x_kde[0],kk)[0]
    B = quad(kde_func_curve,x_kde[0],kk)[0]
    C = quad(kde_func_curve_x,kk,x_kde[-1])[0]
    D = quad(kde_func_curve,kk,x_kde[-1])[0]
    temp = oh*(A/B+C/D)
    G_k.append(temp)

G_k = np.asarray(G_k)
plt.plot(x_kde[1:-1],G_k)
plt.grid()
plt.title('Plot of G(k)')
plt.show()

kstar_0 = G_k-x_kde[1:-1]
plt.plot(x_kde[1:-1],kstar_0)
plt.grid()
plt.title('Plot of G(k)-k')
plt.show()

G_k_minus_k_func = PchipInterpolator(x_kde[1:-1],kstar_0)
plt.plot(x_kde[1:-1],G_k_minus_k_func(x_kde[1:-1]))
plt.grid()
plt.title('Plot of G(k)-k')
plt.plot(np.array([x_kde[0],x_kde[-1]]),np.array([0.0,0.0]),color='black')
plt.show()

kstar_Newton = newton(G_k_minus_k_func,1)







